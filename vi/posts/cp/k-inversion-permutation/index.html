<!doctype html><html lang=vi><head><title>Hoán vị K-nghịch thế :: Nhut Dang</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Một bài toán bao hàm loại trừ kết hợp Chia kẹo Euler"><meta name=keywords content="[ai nlp llm cp]"><meta name=robots content="noodp"><link rel=canonical href=/vi/posts/cp/k-inversion-permutation/><link rel=stylesheet href=/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=/terminal.css><link rel=stylesheet href=/style.css><link rel="shortcut icon" href=/favicon.png><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="vi"><meta property="og:type" content="article"><meta property="og:title" content="Hoán vị K-nghịch thế"><meta property="og:description" content="Một bài toán bao hàm loại trừ kết hợp Chia kẹo Euler"><meta property="og:url" content="/vi/posts/cp/k-inversion-permutation/"><meta property="og:site_name" content="Nhut Dang"><meta property="og:image" content="/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="cp"><meta property="article:published_time" content="2023-01-18 00:00:00 +0000 UTC"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1},{left:"\\\\[",right:"\\\\]",display:!0}],throwOnError:!1})'></script></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>acsfid</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/vi/>Trang chủ</a></li><li><a href=/vi/publications/>Nghiên cứu</a></li><li><a href=/vi/projects/>Dự án</a></li><li><a href=/vi/posts/>Bài viết</a></li><hr><li><a href=/vi/>Tiếng Việt</a></li><li><a href=/>English</a></li></ul></li></ul><ul class="menu menu--desktop menu--language-selector"><li class=menu__trigger>Tiếng Việt&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/vi/>Tiếng Việt</a></li><li><a href=/>English</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/vi/>Trang chủ</a></li><li><a href=/vi/publications/>Nghiên cứu</a></li><li><a href=/vi/projects/>Dự án</a></li><li><a href=/vi/posts/>Bài viết</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/vi/posts/cp/k-inversion-permutation/>Hoán vị K-nghịch thế</a></h1><div class=post-meta><time class=post-date>2023-01-18</time></div><span class=post-tags>#<a href=/vi/tags/cp/>cp</a>&nbsp;
#<a href=/vi/tags/algorithm/>algorithm</a>&nbsp;
#<a href=/vi/tags/inclusion-exclusion/>inclusion-exclusion</a>&nbsp;
#<a href=/vi/tags/combinatorics/>combinatorics</a>&nbsp;</span><div class=post-content><div><h2 id=cần-biết-trước>Cần biết trước<a href=#cần-biết-trước class=hanchor arialabel=Anchor>#</a></h2><ul><li>Nguyên lí bao hàm loại trừ</li><li>Bài toán Chia kẹo Euler</li></ul><h2 id=đề-bài>Đề bài<a href=#đề-bài class=hanchor arialabel=Anchor>#</a></h2><h3 id=tham-khảo>Tham khảo<a href=#tham-khảo class=hanchor arialabel=Anchor>#</a></h3><ul><li><a href=https://www.hackerrank.com/contests/101hack43/challenges/k-inversion-permutations/problem>HackerRank - K-Inversion Permutations</a></li><li><a href=https://codeforces.com/blog/entry/64625>Codeforces - [Tutorial] Inclusion-Exclusion Principle</a></li></ul><h3 id=tóm-tắt>Tóm tắt<a href=#tóm-tắt class=hanchor arialabel=Anchor>#</a></h3><p>Cho hai số nguyên $n, k$. Đếm số lượng hoán vị của dãy ${1, 2, \dots, n}$ có $k$ cặp nghịch thế.</p><ul><li>Subtask 1: $1 \leq n \leq 3000, 0 \leq k \leq \min(C^2_n, 3000)$</li><li>Subtask 2: $1 \leq n \leq 10^5, 0 \leq k \leq \min(C^2_n, 10^5)$</li></ul><h2 id=phân-tích>Phân tích<a href=#phân-tích class=hanchor arialabel=Anchor>#</a></h2><h3 id=subtask-1-quy-hoạch-động>Subtask 1: Quy hoạch động<a href=#subtask-1-quy-hoạch-động class=hanchor arialabel=Anchor>#</a></h3><p>Độ phức tạp: $\mathcal{O}(nk)$</p><p>Trước khi đến với lời giải chính của bài này. Ta xét một hướng tiếp cận quy hoạch động khi $n$ và $k$ nhỏ. Gọi $\text{dp}[i][j]$ là số lượng hoán vị của dãy ${1, 2, \dots, i}$ có $j$ nghịch thế, ta dễ có công thức sau:
$$
\text{dp}[i][j] = \sum_{x = 0}^{i-1} \text{dp}[i-1][j-x]
$$</p><details><summary>Giải thích công thức</summary><p>Ở một trạng thái $(i, j)$ của hàm quy hoạch động, ta có thể đặt phần tử $i$ vào một trong $i$ vị trí của hoán vị ${1, 2, \dots, i-1}$ đã dựng trước đó. Số nghịch thế thay đổi như sau:</p><ul><li>Đặt vào vị trí cuối dãy, số nghịch thế không thay đổi.</li><li>Đặt vào trước phần tử cuối, số nghịch thế tăng lên $1$ do phần tử $i$ lớn hơn các phần tử đã điền và có 1 phần tử đứng sau $i$.</li><li>&mldr;</li><li>Đặt vào vị trí đầu dãy, số nghịch thế tăng lên $i-1$ do có $i-1$ phần tử nhỏ hơn $i$ và đứng sau $i$.</li></ul><p>Tóm lại, khi đặt phần tử $i$ vào một vị trí trong hoán vị đã dựng, số nghịch thế tăng lên sẽ bằng số phần tử đứng sau $i$, do $i$ lớn hơn tất cả phần tử đã điền.</p></details><p>Đáp án của bài toán sẽ là $\text{dp}[n][k]$. Ta sẽ được thuật toán có độ phức tạp là $\mathcal{O}(nk^2)$, từ đó ta có thể dùng mảng cộng dồn để cải tiến thành $\mathcal{O}(nk)$.</p><h3 id=subtask-2-bao-hàm-loại-trừ>Subtask 2: Bao hàm loại trừ<a href=#subtask-2-bao-hàm-loại-trừ class=hanchor arialabel=Anchor>#</a></h3><p>Độ phức tạp: $\mathcal{O}(k\sqrt{k})$</p><h4 id=nhận-xét>Nhận xét<a href=#nhận-xét class=hanchor arialabel=Anchor>#</a></h4><p>Trong công thức quy hoạch động trên, ta nhận thấy khi thêm phần tử thứ $i$ vào hoán vị, số cặp nghịch thế lại tăng thêm. Ta gọi lượng tăng thêm đó là $x_i$. Khi đó, bài toán trở thành đếm số dãy số $(x_1, x_2, \dots, x_n)$ phân biệt thỏa mãn:
$$
x_1 + x_2 + \dots + x_n = k
\text { và } 0 \leq x_i \leq i-1
$$</p><p>Xét phiên bản đơn giản hơn của bài toán: tìm số lượng nghiệm nhưng không có cận trên của $x_i$. Ta dễ dàng dùng công thức Chia kẹo Euler và tìm được đáp án của bài toán là $C_{n-1+k}^{n-1}$. Như vậy, ta cần phải tìm cách loại bỏ điều kiện $x_i \leq i-1$ để có thể dùng công thức trên.</p><h4 id=lời-giải>Lời giải<a href=#lời-giải class=hanchor arialabel=Anchor>#</a></h4><p>Gọi $f(j)$ là số nghiệm của bài toán sao cho có <strong>ít nhất</strong> $j$ phần tử $x_i \geq i$ (phần tử xấu). Giả sử, ta xác định được $j$ phần tử xấu $x_{i_1} \geq i_1, x_{i_2} \geq i_2, \dots, x_{i_j} \geq i_j$ và $s = i_1 + i_2 + \dots + i_j$. Khi đó, ta gọi dãy $y$ sao cho $y_i = x_i - i$ nếu $x_i$ là phần tử xấu, ngược lại ta cho $y_i = x_i$. Như vậy bài toán trở thành đếm số dãy $y$ thỏa mãn:
$$
y_1 + y_2 + \dots + y_n = k - s \text { và }
y_i \geq 0
$$
Áp dụng Chia kẹo Euler, số lượng dãy thỏa mãn trong trường hợp này là $C^{n-1}_{n-1+(k-s)}$</p><p>Như vậy ta có cách tính $f(j)$ như sau: Gọi $g(s, j)$ là số cách chọn $j$ số nguyên <strong>phân biệt</strong> thuộc $[1, n]$ sao cho tổng của chúng là $s$. Khi đó:
$$f(j) = \sum_{s = 0}^{k} g(s, j)\times C^{n-1}_{n-1+k-s}$$</p><p>Ta nhận thấy do $j$ số nguyên <strong>phân biệt</strong> nên $j \leq \sqrt{k}$, vì vậy ta có thể tính $g(s, j)$ bằng quy hoạch động trong $O(k\sqrt{k})$ theo công thức:
$$
g(s, j) = g(s-j, j) + g(s-j, j-1) - g(s-(n+1), j-1)
$$</p><details><summary>Giải thích công thức</summary><p>Tại trạng thái $(s, j)$ - $j$ phần tử có tổng là $s$, ta có hai trường hợp chuyển trạng thái:</p><ul><li>$g(s-j, j)$: Tăng tất cả phần tử, mỗi phần tử thêm $1$ đơn vị.</li><li>$g(s-j, j-1) - g(s-(n+1), j-1)$: Tăng tất cả phần tử trước đó, mỗi phần tử thêm $1$ đơn vị, và tạo thêm một phần tử mới có giá trị là $1$. Sau đó, ta phải loại đi các trường hợp dãy có phần tử lớn hơn $n$.</li></ul></details><p>Cuối cùng, áp dụng nguyên lí bao hàm loại trừ, ta có công thức cho đáp án như sau:
$$
\text{answer} = \sum_{j = 0}^{\sqrt{k}} (-1)^j f(j)
$$</p><h4 id=code-tham-khảo>Code tham khảo<a href=#code-tham-khảo class=hanchor arialabel=Anchor>#</a></h4><details><summary>Hãy xem code khi thực sự cần thiết</summary><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Created by BJMinhNhut
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span><span style=color:#75715e>#define mp make_pair
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define pb push_back
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define fi first
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define se second
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define FOR(i, a, b) for(int i = (a), _b = (b); i &lt;= _b; ++i) 
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define FORD(i, a, b) for(int i = (a), _b = (b); i &gt;= _b; --i)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define ALL(a) (a).begin(), (a).end()
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define RALL(a) (a).rbegin(), (a).rend()
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MASK(i) (1ll&lt;&lt;(i))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BIT(t, i) (((t)&gt;&gt;(i))&amp;1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> ll;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vi;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> vector<span style=color:#f92672>&lt;</span>ll<span style=color:#f92672>&gt;</span> vll;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> pair<span style=color:#f92672>&lt;</span>ll, ll<span style=color:#f92672>&gt;</span> pll;
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ii;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/***Common Functions***/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> minimize(T <span style=color:#f92672>&amp;</span>a, T b) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;</span> b) {
</span></span><span style=display:flex><span>		a <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> maximize(T <span style=color:#f92672>&amp;</span>a, T b) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&lt;</span> b) {
</span></span><span style=display:flex><span>		a <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> read(T <span style=color:#f92672>&amp;</span>a) {
</span></span><span style=display:flex><span>	a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> c; 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>isdigit(c <span style=color:#f92672>=</span> getchar())) {}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>		a <span style=color:#f92672>=</span> a<span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> (c<span style=color:#f92672>-</span><span style=color:#e6db74>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>while</span> (isdigit(c <span style=color:#f92672>=</span> getchar()));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> write(T a){
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>9</span>) write(a<span style=color:#f92672>/</span><span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>	putchar(a<span style=color:#f92672>%</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;0&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/***End of Template***/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n, k;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e5</span><span style=color:#f92672>+</span><span style=color:#ae81ff>5</span>, SQRT <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span>, MOD <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> fact[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>N], inv[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>N];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> dp[N][SQRT];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Input</span>() {
</span></span><span style=display:flex><span>	cin <span style=color:#f92672>&gt;&gt;</span> n <span style=color:#f92672>&gt;&gt;</span> k;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>modPow</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (b) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (b<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>) res <span style=color:#f92672>=</span> <span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>res<span style=color:#f92672>*</span>a <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>		a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>a<span style=color:#f92672>*</span>a<span style=color:#f92672>%</span>MOD;
</span></span><span style=display:flex><span>		b <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>	a <span style=color:#f92672>+=</span> b;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&gt;=</span> MOD) a<span style=color:#f92672>-=</span> MOD;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sub</span>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>	a <span style=color:#f92672>-=</span> b;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (a <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) a <span style=color:#f92672>+=</span> MOD;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ll <span style=color:#a6e22e>minSum</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>n<span style=color:#f92672>*</span>(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>prepare</span>() {
</span></span><span style=display:flex><span>	fact[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	FOR(i, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) fact[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>fact[i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>i <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>	inv[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> modPow(fact[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>N<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], MOD<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>	FORD(i, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>N<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>) inv[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>inv[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>(i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	memset(dp, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> dp);
</span></span><span style=display:flex><span>	dp[<span style=color:#ae81ff>0</span>][<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> sqrt_k <span style=color:#f92672>=</span> sqrt(k);
</span></span><span style=display:flex><span>	FOR(s, <span style=color:#ae81ff>1</span>, k) <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; minSum(i) <span style=color:#f92672>&lt;=</span> s; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (s<span style=color:#f92672>-</span>i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) dp[s][i] <span style=color:#f92672>=</span> (dp[s<span style=color:#f92672>-</span>i][i] <span style=color:#f92672>+</span> dp[s<span style=color:#f92672>-</span>i][i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (s<span style=color:#f92672>-</span>(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) sub(dp[s][i], dp[s<span style=color:#f92672>-</span>(n<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)][i<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>nCr</span>(<span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> r) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&lt;</span> r) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>fact[n]<span style=color:#f92672>*</span>inv[r] <span style=color:#f92672>%</span> MOD <span style=color:#f92672>*</span> inv[n<span style=color:#f92672>-</span>r] <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>calc</span>(<span style=color:#66d9ef>int</span> j) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	FOR(s, minSum(j), k) {
</span></span><span style=display:flex><span>		add(ans, <span style=color:#ae81ff>1ll</span><span style=color:#f92672>*</span>nCr(n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>+</span>k<span style=color:#f92672>-</span>s, n<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>*</span>dp[s][j] <span style=color:#f92672>%</span> MOD);
</span></span><span style=display:flex><span>	} 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ans;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Solve</span>() {
</span></span><span style=display:flex><span>	prepare();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> ans <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; minSum(j) <span style=color:#f92672>&lt;=</span> k; <span style=color:#f92672>++</span>j) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (j<span style=color:#f92672>&amp;</span><span style=color:#ae81ff>1</span>) sub(ans, calc(j));
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>else</span> add(ans, calc(j));
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	cout <span style=color:#f92672>&lt;&lt;</span> ans;
</span></span><span style=display:flex><span>}	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	ios<span style=color:#f92672>::</span>sync_with_stdio(<span style=color:#ae81ff>0</span>); cin.tie(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (fopen(<span style=color:#e6db74>&#34;inputf.in&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>)) freopen(<span style=color:#e6db74>&#34;inputf.in&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>, stdin);
</span></span><span style=display:flex><span>	Input(), Solve();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Các bài viết khác</span><hr></div><div class=pagination__buttons><a href=/vi/posts/cp/parallel-binary-search/ class="button inline next">[<span class=button__text>Chặt nhị phân song song</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>